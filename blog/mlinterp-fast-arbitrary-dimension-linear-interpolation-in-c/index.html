<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>mlinterp - Fast arbitrary dimension linear interpolation in C++ &mdash; Parsiad Azimzadeh</title>
  <link href="/assets/main.css" rel="stylesheet">
  <link href="/atom.xml" rel="alternate" title="Blog &mdash; Parsiad Azimzadeh" type="application/atom+xml">
  <link crossorigin href="https://fonts.googleapis.com" rel="preconnect">
  <link crossorigin href="https://fonts.gstatic.com" rel="preconnect">
  <link crossorigin href="https://fonts.googleapis.com/css2?family=EB+Garamond&family=Source+Code+Pro&display=swap" rel="stylesheet">
  <link crossorigin href="https://cdn.jsdelivr.net/npm/modern-normalize@3.0.1/modern-normalize.min.css" integrity="sha384-uo/9/s/Ns8DTg4kjkjex8GezUcgMlKD99gTqxvMkIsaG4lSUbeJ0dVELljipv94t" rel="stylesheet">
  <link crossorigin href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css" integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew" rel="stylesheet">
  <link crossorigin href="https://cdn.jsdelivr.net/npm/glightbox@3.3.1/dist/css/glightbox.min.css" integrity="sha384-GPAzSuZc0kFvdIev6wm9zg8gnafE8tLso7rsAYQfc9hAdWCpOcpcNI5W9lWkYcsd" rel="stylesheet">
  <link crossorigin rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/base16/equilibrium-gray-light.min.css">
  <script src="/assets/main.js"></script>
  <script type="module" src="/assets/module.js"></script>
  <script crossorigin defer integrity="sha384-2B8pfmZZ6JlVoScJm/5hQfNS2TI/6hPqDZInzzPc8oHpN5SgeNOf4LzREO6p5YtZ" src="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.js"></script>
  <script crossorigin defer integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" src="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/contrib/auto-render.min.js"></script>
  <script crossorigin integrity="sha384-MZZbZ6RXJudK43v1qY1zOWKOU2yfeBPatuFoKyHAaAgHTUZhwblRTc9CphTt4IGQ" src="https://cdn.jsdelivr.net/npm/glightbox@3.3.1/dist/js/glightbox.min.js"></script>
</head>

<body>
  <h1>Parsiad Azimzadeh</h1>
  <nav>
    <ul>
      <li><a href="/">About</a></li><li><a href="/blog/">Blog</a></li><li><a href="/pubs/">Publications</a></li><li><a href="/code/">Code</a></li><li><a href="/sols/">Solutions</a></li>
    </ul>
  </nav>
  <div id="content">
<h1 class="title">mlinterp - Fast arbitrary dimension linear interpolation in C++</h1>
<time datetime="2017-06-19">June 19, 2017</time>
<p>I made a header-only C++ library for arbitrary dimension <a rel="external" href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation</a> (a.k.a. multilinear interpolation).
The design philosophy is to push as much to compile-time as possible by <a rel="external" href="https://en.wikipedia.org/wiki/Template_metaprogramming">template metaprogramming</a>.</p>
<p>Instructions for how to include it in your work are on <a rel="external" href="https://github.com/parsiad/mlinterp">the GitHub project page</a>.</p>
<p>Below are some simple examples of its usage.</p>
<h2 id="examples">Examples</h2>
<h3 id="1d">1d</h3>
<p>Let's interpolate y = sin(x) on the interval [-pi, pi] using 15 evenly-spaced data points.</p>
<pre><code data-lang="c++">using namespace mlinterp;

// Boundaries of the interval [-pi, pi]
constexpr double b = 3.14159265358979323846, a = -b;

// Subdivide the interval [-pi, pi] using 15 evenly-spaced points and
// evaluate sin(x) at each of those points
constexpr int nxd = 15, nd[] = { nxd };
double xd[nxd];
double yd[nxd];
for(int n = 0; n &lt; nxd; ++n) {
	xd[n] = a + (b - a) / (nxd - 1) * n;
	yd[n] = sin(xd[n]);
}

// Subdivide the interval [-pi, pi] using 100 evenly-spaced points
// (these are the points at which we interpolate)
constexpr int ni = 100;
double xi[ni];
for(int n = 0; n &lt; ni; ++n) {
	xi[n] = a + (b - a) / (ni - 1) * n;
}

// Perform the interpolation
double yi[ni]; // Result is stored in this buffer
interp(
	nd, ni, // Number of points
	yd, yi, // Output axis (y)
	xd, xi  // Input axis (x)
);

// Print the interpolated values
cout &lt;&lt; scientific &lt;&lt; setprecision(8) &lt;&lt; showpos;
for(int n = 0; n &lt; ni; ++n) {
	cout &lt;&lt; xi[n] &lt;&lt; &quot;\t&quot; &lt;&lt; yi[n] &lt;&lt; endl;
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/parsiad/mlinterp/master/images/1d.png" alt="" /></p>
<p>Note that the points do not have to be evenly spaced. Try modifying the above to use a non-uniform grid!</p>
<h3 id="2d">2d</h3>
<p>Let's interpolate z = sin(x)cos(y) on the interval [-pi, pi] X [-pi, pi] using 15 evenly-spaced points along the x axis and 15 evenly-spaced points along the y axis.</p>
<pre><code data-lang="c++">using namespace mlinterp;

// Boundaries of the interval [-pi, pi]
constexpr double b = 3.14159265358979323846, a = -b;

// Discretize the set [-pi, pi] X [-pi, pi] using 15 evenly-spaced
// points along the x axis and 15 evenly-spaced points along the y axis
// and evaluate sin(x)cos(y) at each of those points
constexpr int nxd = 15, nyd = 15, nd[] = { nxd, nyd };
double xd[nxd];
for(int i = 0; i &lt; nxd; ++i) {
	xd[i] = a + (b - a) / (nxd - 1) * i;
}
double yd[nyd];
for(int j = 0; j &lt; nyd; ++j) {
	yd[j] = a + (b - a) / (nyd - 1) * j;
}
double zd[nxd * nyd];
for(int i = 0; i &lt; nxd; ++i) {
	for(int j = 0; j &lt; nyd; ++j) {
		const int n = j + i * nyd;
		zd[n] = sin(xd[i]) * cos(yd[j]);
	}
}

// Subdivide the set [-pi, pi] X [-pi, pi] using 100 evenly-spaced
// points along the x axis and 100 evenly-spaced points along the y axis
// (these are the points at which we interpolate)
constexpr int m = 100, ni = m * m;
double xi[ni];
double yi[ni];
for(int i = 0; i &lt; m; ++i) {
	for(int j = 0; j &lt; m; ++j) {
		const int n = j + i * m;
		xi[n] = a + (b - a) / (m - 1) * i;
		yi[n] = a + (b - a) / (m - 1) * j;
	}
}

// Perform the interpolation
double zi[ni]; // Result is stored in this buffer
interp(
	nd, ni,        // Number of points
	zd, zi,        // Output axis (z)
	xd, xi, yd, yi // Input axes (x and y)
);

// Print the interpolated values
cout &lt;&lt; scientific &lt;&lt; setprecision(8) &lt;&lt; showpos;
for(int n = 0; n &lt; ni; ++n) {
	cout &lt;&lt; xi[n] &lt;&lt; &quot;\t&quot; &lt;&lt; yi[n] &lt;&lt; &quot;\t&quot; &lt;&lt; zi[n] &lt;&lt; endl;
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/parsiad/mlinterp/master/images/2d.png" alt="" /></p>
<p>Note that the x and y axes do not have to be identical: they can each have any number of unequally spaced points. Try modifying the above to use different x and y axes!</p>
<h2 id="higher-dimensions-3d-4d">Higher dimensions (3d, 4d, ...)</h2>
<p>In general, if you have k dimensions with axes x1, x2, ..., xk, the interp routine is called as follows:</p>
<pre><code data-lang="c++">interp(
	nd,  ni,                          // Number of points
	yd,  yi,                          // Output axis
	x1d, x1i, x2d, x2i, ..., xkd, xki // Input axes
);
</code></pre>

</div>
  <footer>Powered by <a href="https://getzola.org/">Zola</a></footer>
</body>

</html>